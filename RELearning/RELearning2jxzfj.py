# -*- coding: utf-8 -*-
import re

# 简写字符集

'''
正则表达式为常用的字符集和常用的正则表达式提供了简写。
简写字符集如下：

简写               描述
 .          匹配除换行符以外的任意字符
\w          匹配所有字母和数字的字符：[a-zA-Z0-9_]
\W          匹配非字母和数字的字符： [^\w]
\d          匹配数字 [0-9]
\D          匹配非数字 [^\d]
\s          匹配空格符 [\t\n\f\r\p{Z}]
\S          匹配非空格符 [^\s]

'''

'''
《断言》
后行断言和先行断言 有时候被称为断言，它们是特殊类型的 非捕获组（用于匹配模式，但不包括在匹配列表中）。
当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。例如我们想获取输入字符串 $4.44 and $10.88
中 $ 字符之前的所有数字。我们可以使用这个正则表达式(?<=\$)[0-9\.]*  表示获取 $ 字符之前的所有的数字
包含 . 字符。以下是正则表达式中使用的断言

符号             描述
?=          正向先行断言
?!          负向先行断言
?<=         正向后行断言
?<!         负向后行断言

'''

m = '$4.44 and $10.88'
print (re.findall('(?<=\$)[0-9\.]* ',m))

'''
正向先行断言
正向先行断言认为第一部分的表达式必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。
要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 (?=...)。先行断言表达式写在括号中的等号后面。 
例如正则表达式 (T|t)he(?=\sfat)，表示: 匹配大写字母 T 或小写字母 t，后面跟字母 h，后跟字母 e。
在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配 The 或 the 后面跟着 fat。

负向先行断言

当我们需要从输入字符串中获取不匹配表达式的内容时，使用负向先行断言。
负向先行断言的定义跟我们定义的正向先行断言一样， 唯一的区别是不是等号 =，我们使用否定符号 !，例如 (?!...)。 
我们来看看下面的正则表达式 (T|t)he(?!\sfat)，表示: 从输入字符串中获取全部 The 或者 the 且不匹配 fat 前面加上一个空格字符。

正向后行断言

正向后行断言是用于获取在特定模式之前的所有匹配内容。正向后行断言表示为 (?<=...)。例如正则表达式 (?<=(T|t)he\s)(fat|mat)，
表示: 从输入字符串中获取在单词 The 或 the 之后的所有 fat 和 mat 单词。

负向后行断言

负向后行断言是用于获取不在特定模式之前的所有匹配的内容。负向后行断言表示为 (?<!...)。例如正则表达式 (?<!(T|t)he\s)(cat)，
表示: 在输入字符中获取所有不在 The 或 the 之后的所有单词 cat。

'''

'''
标记

标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。


标记 	描述
i 	不区分大小写: 将匹配设置为不区分大小写。
g 	全局搜索: 搜索整个输入字符串中的所有匹配。
m 	多行匹配: 会匹配输入字符串每一行。


不区分大小写

i 修饰符用于执行不区分大小写匹配。例如正则表达式 /The/gi，表示: 大写字母 T，后跟小写字母 h，后跟字母 e。
 但是在正则匹配结束时 i 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 g 标记，
 因为我们要在整个输入字符串中搜索匹配。
 

全局搜索

g 修饰符用于执行全局匹配 (会查找所有匹配，不会在查找到第一个匹配时就停止)。 
例如正则表达式 /.(at)/g，表示: 除换行符之外的任意字符，后跟小写字母 a，后跟小写字母 t。 
因为我们在正则表达式的末尾使用了 g 标记，它会从整个输入字符串中找到每个匹配项。


多行匹配

m 修饰符被用来执行多行的匹配。正如我们前面讨论过的 (^, $)，使用定位符来检查匹配字符是输入字符串开始或者结束。
但是我们希望每一行都使用定位符，所以我们就使用 m 修饰符。 例如正则表达式 /at(.)?$/gm，表示: 小写字母 a，后跟小写字母 t，
匹配除了换行符以外任意字符零次或一次。而且因为 m 标记，现在正则表达式引擎匹配字符串中每一行的末尾。

'''